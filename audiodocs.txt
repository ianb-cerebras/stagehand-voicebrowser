Module livekit.rtc.audio_source
Classes
class AudioSource
(
sample_rate: int,
num_channels: int,
queue_size_ms: int = 1000,
loop: asyncio.AbstractEventLoop | None = None)
Expand source code
Represents a real-time audio source with an internal audio queue.

The AudioSource class allows you to push audio frames into a real-time audio source, managing an internal queue of audio data up to a maximum duration defined by queue_size_ms. It supports asynchronous operations to capture audio frames and to wait for the playback of all queued audio data.

Initializes a new instance of the audio source.

Args
sample_rate : int
The sample rate of the audio source in Hz.
num_channels : int
The number of audio channels.
queue_size_ms : int, optional
The buffer size of the audio queue in milliseconds. Defaults to 1000 ms.
loop : asyncio.AbstractEventLoop, optional
The event loop to use. Defaults to asyncio.get_event_loop().
Instance variables
prop num_channels : int
Expand source code
The number of audio channels.

prop queued_duration : float
Expand source code
The current duration (in seconds) of audio data queued for playback.

prop sample_rate : int
Expand source code
The sample rate of the audio source in Hz.

Methods
async def aclose
(
self) ‑> None
Expand source code
Close the audio source

This method cleans up resources associated with the audio source.

async def capture_frame
(
self, frame: AudioFrame) ‑> None
Expand source code
Captures an AudioFrame and queues it for playback.

This method is used to push new audio data into the audio source. The audio data will be processed and queued. If the size of the audio frame exceeds the internal queue size, the method will wait until there is enough space in the queue to accommodate the frame. The method returns only when all of the data in the buffer has been pushed.

Args
frame : AudioFrame
The audio frame to capture and queue.
Raises
Exception
If there is an error during frame capture.
def clear_queue
(
self) ‑> None
Expand source code
Clears the internal audio queue, discarding all buffered audio data.

This method immediately removes all audio data currently queued for playback, effectively resetting the audio source's buffer. Any audio frames that have been captured but not yet played will be discarded. This is useful in scenarios where you need to stop playback abruptly or prevent outdated audio data from being played.

async def wait_for_playout
(
self) ‑> None
Expand source code
Waits for the audio source to finish playing out all audio data.

This method ensures that all queued audio data has been played out before returning. It can be used to synchronize events after audio playback or to ensure that the audio queue is empty.

